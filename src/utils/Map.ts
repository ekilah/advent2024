import * as R from 'ramda'
import * as RA from 'ramda-adjunct'

/** Get an Array of [key, value] pairs from a given Map */
export const entries = <K, V>(m: Map<K, V>): Array<[K, V]> => {
  return Array.from(m.entries())
}

/** Get an Array of the values of a given Map */
export const values = <V>(m: Map<any, V>): Array<V> => {
  return Array.from(m.values())
}

/** Return a subset of a Map, where a pair is included in the new Map iff the predicate returns true for it. */
export const filter = <K, V>(
  predicate: (value: V, key: K) => boolean,
  m: Map<K, V>
): Map<K, V> => {
  const filtered = new Map<K, V>()
  m.forEach((value: V, key: K) => {
    if (predicate(value, key)) {
      filtered.set(key, value)
    }
  })
  return filtered
}

/** Return a subset of a Map, where only keys in keepKeys are kept the new Map. */
export const keep = <K, V>(keepKeys: K | K[] | Set<K>, m: Map<K, V>): Map<K, V> => {
  const _set = keepKeys instanceof Set ? keepKeys : new Set(RA.ensureArray(keepKeys))
  return filter((v, k) => _set.has(k), m)
}

/** Returns a new map, where each value is generated by the given function from the map's keys and values. */
export const map = <NewV, K, V>(
  func: (value: V, key: K, index: number) => NewV,
  m: Map<K, V>
): Map<K, NewV> => {
  const newM = new Map<K, NewV>()
  forEachIndexed((value, key, i) => {
    newM.set(key, func(value, key, i))
  }, m)
  return newM
}

/** Iterates over a given map, calling the given function with each (value, key, index) */
export const forEachIndexed = <K, V>(
  func: (value: V, key: K, index: number) => void,
  m: Map<K, V>
): void => {
  let count: number = 0
  m.forEach((value: V, key: K) => {
    func(value, key, count++)
  })
}

type ComparatorFunction<T> = (a: T, b: T) => number

/** JS Maps are kept in insertion order, so they are ordered. Reorder values via a list of comparators. */
export const sort = <K, V>(
  comparators: Array<ComparatorFunction<V>>,
  m: Map<K, V>
): Map<K, V> => {
  // given comparators only sort by value, but we need to get a list of [k,v] pairs out of the sort, so wrap them
  const sortedEntries: [K, V][] = R.sortWith<[K, V]>(
    comparators.map(func => {
      return (e1: [K, V], e2: [K, V]) => func(e1[1], e2[1])
    }),
    entries(m)
  )

  return new Map<K, V>(sortedEntries)
}

/** Get an Array of the keys of a given Map */
export const keys = <K>(m: Map<K, any>): Array<K> => {
  return Array.from(m.keys())
}

/** Get a Set of the keys of a given Map */
export const keySet = <K>(m: Map<K, any>): Set<K> => {
  return new Set(m.keys())
}

/**
 * Splits a list into sublists stored in a Map, where the keys are generated by calling the given key-returning
 * function on each element, and the values are an array of list items that were given the same key by the function.
 */
export const groupBy = <K, V>(
  groupingFunc: (listItem: V) => K,
  list: ReadonlyArray<V>
): Map<K, V[]> => {
  const m = new Map<K, V[]>()

  list.forEach(li => {
    const k = groupingFunc(li)
    const existing = m.get(k)
    if (existing !== undefined) {
      m.set(k, [...existing, li])
    } else {
      m.set(k, [li])
    }
  })

  return m
}
